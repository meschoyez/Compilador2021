Herramientas similares a ANTLR:
 - Lex y Yacc - AT&T luego de la creación de C
    Lex  - Lexical Analyzer
    Yacc - Yet Another Compiler of Compilers
 - Flex (léxico) y Bison (sintáctico) - GNU las usa GCC

-- ANTLR (ANother Tool for Language Recognition) --

Expresiones Regulares (regexp)

Recorrido iterativo sobre secuencias de caracteres

WS -> WhiteSpace

Shell (Bash) --> * -> 0 o más veces de algo (no WS)
                 ? -> 1 caracter cualquiera (no WS)
                 
  ej: $ cp .??* nuevoDir

grep? awk?

ANTLR -->
 Metacaracteres
   . -> cualquier caracter
   ? -> 0 o 1 caracter
   * -> 0 o más caracteres
   + -> 1 o más caracteres
 
 Operaciones
   a b   -> yuxtaposición  -> 'i' 'n' 't'
   a | b -> selección      -> '2' | 'x'
   (a b) -> agrupación
   [a-b] -> secuencia (por extensión) solo "-" es etacaracter
            [ \t\n]
            [a-z] [A-Z] [A-Za-z] [AEIOU] [k-m]
            [0-9] [02468]
            rangos numéricos -> horas día ([01][0-9])|('2'[0-3])
            [-+*/]
    ~a   -> negación  -> ~[.,;:] (tilde -EN- / virgulilla -ES-)

-----------------
Ejercitación

Dado un texto con palabras en oraciones, números, horas en formato HH:MM y fechas en formato DD/MM/YYYY, escribir las regexp que hagan match con:
1) Palabras con Mayúscula inicial
2) Palabras fin de oración
3) Palabras en plural que comienzan con letra
4) Horas entre las 13:00 y 15:59
5) Horas entre las 03:12 y 11:27
6) Fechas de años entre 2000 y 2020
7) Fechas de meses pares
8) Fechas de días entre el 12 y 23

-----------------

Análisis Sintáctico (Gramatical)

Mira la estructura del lenguaje

   La árbol vuela. --> OK léxica y sintacticamente

Dos formas de realizar el análisis sintáctico:
 - Descendente --> ANTLR
 - Ascendente  --> Yacc/Bison

Forma de trabajo --> recursión

Regla de Balance de Paréntesis:

s : '(' s ')' s
  |      // Regla vacía - interrumpe recursión - lambda o epsilon
  ;

==> ()  ==> ()()()  ==> ((())) ==> (())()((()))

Análisis Sintáctico Descendente

Vamos desde la raíz hacia las hojas del árbol.
   raíz -> regla gramatical -> símbolo inicial
   ramas -> unen nodos entre sí y con hojas
   nodos -> son regla gramaticales -> raíz nodo particular
   hojas -> reglas léxicas -> 
   
Derivar -> aplicar una regla gramatical
Match   -> se verifica coindencia del token

Tabla de Análisis Sintáctico Descendente

(pila)
$ SimboloInicial       input $
...
$ (vacío)            (vacío) $ OK


s : '(' s ')' s
  |
  ;

Entrada es: (())()

$ s                (())() $ Derivar
$ s ) s (          (())() $ Match
$ s ) s             ())() $ Derivar
$ s ) s ) s (       ())() $ Match
$ s ) s ) s          ))() $ Derivar
$ s ) s )            ))() $ Match
$ s ) s               )() $ Derivar
$ s )                 )() $ Match
$ s                    () $ Derivar
$ s ) s (              () $ Match
$ s ) s                 ) $ Derivar
$ s )                   ) $ Match
$ s                       $ Derivar
$                         $ OK

              s
          /  / \  \
         (  s   )   s
          // \\    /|\\
         ( s ) s  ( s ) s
           |   |    |   |


Entrada es: (()()

$ s                 (()() $ Derivar
$ s ) s (           (()() $ Match
$ s ) s              ()() $ Derivar
$ s ) s ) s (        ()() $ Match
$ s ) s ) s           )() $ Derivar
$ s ) s )             )() $ Match
$ s ) s                () $ Derivar
$ s ) s ) s (          () $ Match
$ s ) s ) s             ) $ Derivar
$ s ) s )               ) $ Match
$ s ) s                   $ Derivar
$ s )                     $ ERROR


Entrada es: (()))()

$ s                (()))() $ Derivar
$ s ) s (          (()))() $ Match
$ s ) s             ()))() $ Derivar
$ s ) s ) s (       ()))() $ Match
$ s ) s ) s          )))() $ Derivar
$ s ) s )            )))() $ Match
$ s ) s               ))() $ Derivar
$ s )                 ))() $ Match
$ s                    )() $ Derivar
$                      )() $ ERROR

