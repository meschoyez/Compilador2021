Herramientas similares a ANTLR:
 - Lex y Yacc - AT&T luego de la creación de C
    Lex  - Lexical Analyzer
    Yacc - Yet Another Compiler of Compilers
 - Flex (léxico) y Bison (sintáctico) - GNU las usa GCC

-- ANTLR (ANother Tool for Language Recognition) --

Expresiones Regulares (regexp)

Recorrido iterativo sobre secuencias de caracteres

WS -> WhiteSpace

Shell (Bash) --> * -> 0 o más veces de algo (no WS)
                 ? -> 1 caracter cualquiera (no WS)
                 
  ej: $ cp .??* nuevoDir

grep? awk?

ANTLR -->
 Metacaracteres
   . -> cualquier caracter
   ? -> 0 o 1 caracter
   * -> 0 o más caracteres
   + -> 1 o más caracteres
 
 Operaciones
   a b   -> yuxtaposición  -> 'i' 'n' 't'
   a | b -> selección      -> '2' | 'x'
   (a b) -> agrupación
   [a-b] -> secuencia (por extensión) solo "-" es etacaracter
            [ \t\n]
            [a-z] [A-Z] [A-Za-z] [AEIOU] [k-m]
            [0-9] [02468]
            rangos numéricos -> horas día ([01][0-9])|('2'[0-3])
            [-+*/]
    ~a   -> negación  -> ~[.,;:] (tilde -EN- / virgulilla -ES-)

-----------------
Ejercitación

Dado un texto con palabras en oraciones, números, horas en formato HH:MM y fechas en formato DD/MM/YYYY, escribir las regexp que hagan match con:
1) Palabras con Mayúscula inicial
2) Palabras fin de oración
3) Palabras en plural que comienzan con letra
4) Horas entre las 13:00 y 15:59
5) Horas entre las 03:12 y 11:27
6) Fechas de años entre 2000 y 2020
7) Fechas de meses pares
8) Fechas de días entre el 12 y 23

-----------------

Análisis Sintáctico (Gramatical)

Mira la estructura del lenguaje

   La árbol vuela. --> OK léxica y sintacticamente

Dos formas de realizar el análisis sintáctico:
 - Descendente --> ANTLR
 - Ascendente  --> Yacc/Bison

Forma de trabajo --> recursión

Regla de Balance de Paréntesis:

s : '(' s ')' s
  |      // Regla vacía - interrumpe recursión - lambda o epsilon
  ;

==> ()  ==> ()()()  ==> ((())) ==> (())()((()))

Análisis Sintáctico Descendente

Vamos desde la raíz hacia las hojas del árbol.
   raíz -> regla gramatical -> símbolo inicial
   ramas -> unen nodos entre sí y con hojas
   nodos -> son regla gramaticales -> raíz nodo particular
   hojas -> reglas léxicas -> 
   
Derivar -> aplicar una regla gramatical
Match   -> se verifica coindencia del token

Tabla de Análisis Sintáctico Descendente

(pila)
$ SimboloInicial       input $
...
$ (vacío)            (vacío) $ OK


s : '(' s ')' s
  |
  ;

Entrada es: (())()

$ s                (())() $ Derivar
$ s ) s (          (())() $ Match
$ s ) s             ())() $ Derivar
$ s ) s ) s (       ())() $ Match
$ s ) s ) s          ))() $ Derivar
$ s ) s )            ))() $ Match
$ s ) s               )() $ Derivar
$ s )                 )() $ Match
$ s                    () $ Derivar
$ s ) s (              () $ Match
$ s ) s                 ) $ Derivar
$ s )                   ) $ Match
$ s                       $ Derivar
$                         $ OK

              s
          /  / \  \
         (  s   )   s
          // \\    /|\\
         ( s ) s  ( s ) s
           |   |    |   |


Entrada es: (()()

$ s                 (()() $ Derivar
$ s ) s (           (()() $ Match
$ s ) s              ()() $ Derivar
$ s ) s ) s (        ()() $ Match
$ s ) s ) s           )() $ Derivar
$ s ) s )             )() $ Match
$ s ) s                () $ Derivar
$ s ) s ) s (          () $ Match
$ s ) s ) s             ) $ Derivar
$ s ) s )               ) $ Match
$ s ) s                   $ Derivar
$ s )                     $ ERROR


Entrada es: (()))()

$ s                (()))() $ Derivar
$ s ) s (          (()))() $ Match
$ s ) s             ()))() $ Derivar
$ s ) s ) s (       ()))() $ Match
$ s ) s ) s          )))() $ Derivar
$ s ) s )            )))() $ Match
$ s ) s               ))() $ Derivar
$ s )                 ))() $ Match
$ s                    )() $ Derivar
$                      )() $ ERROR


-----------------

Análisis sintáctico Ascendente - desde las hojas hacia la raíz
(Yacc y Bison)

Las acciones son Desplazar y Reducir

$ (vacío)              input $ 
...
$ SimboloInicial     (vacío) $ OK


s : '(' s ')' s
  |
  ;

Entrada es: (())()

$                  (())() $ Desplazar
$ (                 ())() $ Desplazar
$ ((                 ))() $ Reducir
$ ((s                ))() $ Desplazar
$ ((s)                )() $ Reducir
$ ((s)s               )() $ Reducir
$ (s                  )() $ Desplazar
$ (s)                  () $ Desplazar
$ (s)(                  ) $ Reducir
$ (s)(s                 ) $ Desplazar
$ (s)(s)                  $ Reducir
$ (s)(s)s                 $ Reducir
$ (s)s                    $ Reducir
$ s                       $ OK


                      s
               /    /   \   \ 
             /   s       \       s
           /   / | \ \    |   / | \ \
       (      (  s  )  s  )  (  s  )  s
                 |     |        |     |


Entrada es: (()()

$                   (()() $ Desplazar
$ (                  ()() $ Desplazar
$ ((                  )() $ Reducir
$ ((s                 )() $ Desplazar
$ ((s)                 () $ Desplazar
$ ((s)(                 ) $ Reducir
$ ((s)(s                ) $ Desplazar
$ ((s)(s)                 $ Reducir
$ ((s)(s)s                $ Reducir
$ ((s)s                   $ Reducir
$ (s                      $ Error



Entrada es: (()))()

$                  (()))() $ Desplazar
$ (                 ()))() $ Desplazar
$ ((                 )))() $ Reducir
$ ((s                )))() $ Desplazar
$ ((s)                ))() $ Reducir
$ ((s)s               ))() $ Reducir
$ (s                  ))() $ Desplazar
$ (s)                  )() $ Reducir
$ (s)s                 )() $ Reducir
$ s                    )() $ Error



------------------------

Tabla de Símbolos

Incorporar los ID de variables y funciones

Debe controlar ID, si está inicializada y usada, tipo de dato, contexto... entre otras

Opciones de implementación:
   - Lista -> tiene sus dificultados para el manejo de los dificultados
   - Diccionario -> tiene alguna dificultad de manejo, sobre todo al salir del contexto
   - Lista de Diccionarios -> Conviene pensando en hacerlo en Java, Lista doblemente enlazada para los contextos y un Mapa para cada contexto

   

--
#include <stdio.h>

int x = 0, z = 1;

int main () {
  double x = 0.0;

  for (...) {
    int x = 1;

    y = x; ???
    y = z;
  }
  y = x; ???

  return 0;
}

-----------------

¿Cómo recorrer el árbol?

Durante la construcción (al vuelo) con Listeners.

Con el árbol construido, lo recorremos con Visitor.


-----------------

Código de 3 direcciones

TAD -> Three Address Code 

Es un código fuente similar a un ensamblador donde cada
instrucción tiene hasta 3 direcciones de memoria.

***
x = y op z  // ADD AX, BX, CX

x = y op 3
x = y
x = 3

label i
jmp i
ifnot p jmp i

pop
push a
***

Necesitamos dos generadores:
  - generador de variables temporales
  - generador de etiquetas

==
x = 4 * p + r * r / 2 - q / 3;

t0 = 4 * p
t1 = r * r
t2 = t1 / 2
t3 = t0 + t2
t4 = q / 3
t5 = t3 - t4
x = t5

==
if (x < 10)
  y = 7 * x;
else
  y = -7 * x;

t0 = x < 10
ifnot t0 jmp l0
y = 7 * x
jmp l1
label l0
y = -7 * x
label l1

==
for (i = 0; i < 10 ; i++)
   y += x * i;

i = 0
label l0
t0 = i < 10
ifnot t0 jmp l1
t1 = x * i
t2 = y + t1
y = t2
i = i + 1
jmp l0
label l1

==
int f (int a) {
  return a * a;
}
...
y = f(x);


label l0
d = pop
a = pop
t0 = a * a
push a
jmp d

...
push x
push l1
jmp l0
label l1
y = pop



========
 - function inline -> reemplaza llamado a función por el código de la función

x1 = (-b + b * b - 4 * a * c) / 2 / a
x2 = (-b - b * b - 4 * a * c) / 2 / a

t0 = b * b
t1 = 4 * a
t2 = t1 * c
t3 = -1 * b
t4 = t3 + t0
t5 = t4 - t2
t6 = t5 / 2
t7 = t6 / a
x1 = t7
t8 = b * b
t9 = 4 * a
t10 = t9 * c
t11 = -1 * b
t12 = t11 - t8   --> -b - b*b
t13 = t12 - t10
t14 = t13 / 2
t15 = t14 / a
x2 = t15

--- Optimizacion 1

t0 = b * b
t1 = 4 * a
t2 = t1 * c
t3 = -1 * b
t4 = t3 + t0
t5 = t4 - t2
t6 = t5 / 2
x1 = t6 / a
t10 = t1 * c
t12 = t3 - t0
t13 = t12 - t10
t14 = t13 / 2
x2 = t14 / a

--- Optimizacion 2

t0 = b * b
t1 = 4 * a
t2 = t1 * c
t3 = -1 * b
t4 = t3 + t0
t5 = t4 - t2
t6 = t5 / 2
x1 = t6 / a
t12 = t3 - t0
t13 = t12 - t2
t14 = t13 / 2
x2 = t14 / a


===========

y = 2 * x^4 + 3 * x^2 - x / 4 + 5

t0 = x * x
t1 = t0 * x
t2 = t1 * x
t3 = 2 * t2
t4 = x * x
t5 = 3 * t4
t6 = x / 4
t7 = t3 + t5
t8 = t7 - t6
t9 = t8 + 5
y = t9

-- Optimizacion 1

t0 = x * x
t1 = t0 * x
t2 = t1 * x
t3 = 2 * t2
t5 = 3 * t0
t6 = x / 4
t7 = t3 + t5
t8 = t7 - t6
y = t8 + 5


======

y = 4 / 2 * x + 16 / 4

t0 = 4 / 2
t1 = t0 * x
t2 = 16 / 4
t3 = t1 + t2
y = t3

-- Optimizacion 1

t0 = 2
t1 = t0 * x
t2 = 4
y = t1 + t2

-- Optimizacion 2

t1 = 2 * x
y = t1 + 4


